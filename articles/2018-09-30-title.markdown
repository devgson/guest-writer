---
layout: post
title: "Configuring Auth0 as a Custom Authentication System on Firebase"
description: "Learn how to configure Firebase to use Auth0 as a custom authentication system"
date: "2018-09-30 08:30"
author:
  name: "Obielum Godson"
  url: "Devgson_"
  mail: "godsonobielum@yahoo.com"
  avatar: "https://twitter.com/Devgson_/profile_image?size=original"
related:
- 2017-11-15-an-example-of-all-possible-elements
---

# Configuring Auth0 as a Custom Authentication System on Firebase
**TL;DR** In this article, you will learn how to configure Firebase to use Auth0 as a custom authentication system. To get your feet wet on both technologies and on the integration, you will build a simple real-time chat app that will securely store messages on Firestore (a real-time database provided by Firebase), and that will enable users to authenticate through Auth0.

## Prerequisite 
To follow along, it is required that you have a basic understanding of Node.js and Javascript(ES6 to be precise). You'll be using Node.js for the server-side and NPM as a package manager so you need to have both software packages installed, you can skip the next section if you have them installed otherwise follow along.

### Installing Node and NPM
Head over to the official [Node.js](https://nodejs.org/) website, on the homepage you'll see two green links indicating two versions of Node.js, the first is the LTS(stable) version while the second is the current/cutting edge version. Click on the link of the LTS version and download it. When it's done downloading, run the downloaded executable file and make sure the installation completes.

Now NPM comes bundled together with Node so it should have gotten installed as well. To ensure that the installation was successful, open your terminal and run the following commands `node -v` and then `npm -v`. The first command should indicate the version of Node installed on the system while the latter should indicate the version of NPM installed.

## What is Firebase
[Firebase](firebase.google.com) is a platform which allows you to quickly develop web and mobile applications. It provides services that can be easily integrated into your project to provide certain functionalities. One of these services is Cloud Firestore, you'll be using Firestore in this article to setup a real-time database for the chat application.

[Firestore](https://firebase.google.com/docs/firestore/) is a NoSQL database that comes with a plethora of features most notably the real-time feature, this is made possible through the use of [Websockets](https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API) rather than traditional HTTP. It keeps your data in sync across client apps through real-time listeners and also offers offline support so you can build responsive apps that work regardless of Internet connectivity. The Firestore [documentation](https://firebase.google.com/docs/firestore/) explains more of these features in greater depth.


## Why use Firebase and Auth0 together?
You may be wondering what's the need of using an external authentication provider such as Auth0 with Firebase especially if you're familiar with the fact that Firebase offers certain built-in authentication approaches.

It's important to note here that using Auth0 to secure Firebase services doesn't necessarily mean that you won't be using Firebase authentication. As a matter of fact Firebase offers a custom authentication approach using custom tokens which allows you to use your preferred identity provider to secure Firebase rather than the built-in authentication approach already provided by Firebase. So why would you want to use the custom auth approach with Auth0 rather than Firebase's built-in authentication methods? let's go through some reasons why you may consider taking this approach:

* You need to integrate a variety of [social providers](https://auth0.com/docs/identityproviders#social) into your application besides the basic Google, Twitter or Facebook social providers.
* You need to gain more insight into users activity, Auth0 provides powerful reporting and analytics so you can see exactly what's going on.
* You need a robust [user management](https://auth0.com/user-management) system.
* You want to provide enhanced security for your application using features such as Multi-factor authentication, breached password security or anomaly detection.
* You need to able to fully customize any stage of your authorization and authentication pipeline.
* You want to support even more robust registration and login methods such as passwordless login.

In summary, you should go for the custom auth approach if your application requires a more robust and complex authentication method which is usually the case. Thankfully, Firebase provides a way of integrating other authentication solutions into their services, you'll go through it in detail in this article.

## Setting up Firebase
In order to use Firebase you'll need a Firebase account, so go ahead and [sign up](https://firebase.google.com/) for a Firebase account. When you're done with that, the next thing you'll need to do is create a Firebase Project:

* Go to your [Firebase Console](https://console.firebase.google.com/) and click on **Add Project**,
* Give your project a suitable name, and then click on the **Create Project** button.
* A new project should be created and you would be redirected to the **Project overview** page, click on the button as shown in the image below to get your Firebase config properties.

![animated Angular app with global off-canvas navigation](./Firebase_button.png)

A popup should appear showing you some config values perculiar to your Firebase project, copy the `apiKey`, `authDomain` and `projectId` values, you'll use them later on when configuring Firebase on the client.

![animated Angular app with global off-canvas navigation](./Firebase_config_values.png)

With that covered let's setup Firestore, the client application makes use of Firestore Database for storing chat messages, so you'll need to create a new database in your Firebase console. Follow the steps below to create one:

* In the Project overview page, click on the **Database** tab,
* Then click on the **Create Database** button, select the **Start in test mode** option and create the database.

### Generating a Service Account Private Key
Due to the fact that you're using the custom auth approach, you'll need to create a custom token which will be used to authenticate with Firebase. Now Firebase provides an **Admin SDK** that helps with creating this custom token. However, to gain access to the Admin SDK you'll have to create a **service account**, this **service account** will generate a JSON file containing a private key used in signing the custom token. Follow the steps below to generate this file:

* Once again, head over to your Project's overview page, click on the little gear icon  besides `Project Overview` and then click on **Project Settings**, you'd be redirected to the project **settings** page, when that loads, navigate to the **Service Accounts** tab.
* Select the **Firebase Admin SDK** option, the default configuration snippet language is Node.js(which you'll be using). Click on the **Generate new private key** button, a JSON file should automatically start downloading, when it's done store the file somewhere on your system, you'll add it later to the project directory.

> Note : The JSON file containing the private key is highly confidential and shouldn't be commited to any public repository.

## Setting Up Auth0
You'll need an Auth0 account to setup authentication. If you don't have one, go ahead and [sign up](https://auth0.com/signup) for a free Auth0 account. When you're done creating the account, head over to your [dashboard](https://manage.auth0.com) and create a new Auth0 application, follow the steps below to create one:

* Click on the **New Application** button and give your application a suitable name, set the application type to **Single Page Web Applications** and then click on the **Create** button.
* You'd be redirected to the page menu of the newly created application, go the **Settings** tab of the application and copy the **Client ID**, **Client Secret** and **Domain** config values, you'll use them later on to initialize your Auth0 application on the client.
* Lastly, there's an **Allowed Callback URL** field in your application settings, this field specifies a list of allowed URL's users can be redirected to after authentication. You'll want to redirect authenticated users to `http://localhost:3001/` so add that URL to the field and then click on `Save changes`.

## Scaffolding the Web Server
Now that you're done setting up Auth0 and Firebase, the next thing you'll do is to create a directory for the application. Open up your terminal and run the following command:

```
  mkdir firebase-custom-auth
```

When that's done, navigate to that directory and then run the following command in the terminal:

```
  npm init
```

> `npm init` initializes a `package.json` file which helps you keep track of all your project dependencies/packages and also contains some useful information about your application.

You'll be using some packages to help build certain parts of the application on the server-side. Go ahead and install the following packages by running the command below:

```js
  npm install express cors express-jwt jwks-rsa firebase-admin
```

A brief rundown of what these packages will help you achieve:

* `cors`- This package works as an Express middleware, it is used to enable cross-origin resource sharing on the server.
* `express-jwt`- You'll use this package to authenticate HTTP requests using [JSON Web tokens(JWT)](https://jwt.io/). It is essentially an Express middleware that extracts the token(JWT) sent from the HTTP requests `Authorization` header and attempts to validate this token.
* `jwks-rsa`- This package is used to retieve the key used in signing a JWT from a JWKS(JSON Web Key Set) endpoint. In the next section you'll see exactly how this package works.
* `firebase-admin`- This package lets you interact with Firebase services from privileged environments such as servers. You'll be using this package particularly to create custom auth tokens.

### Creating Custom Authentication Tokens
Now everything is set up, let's get to coding but just before that. In your project directory, create a folder called `src`, this folder will contain all your application code both server-side and client-side, within the `src` folder create a file called `server.js`, this is where you'll create the custom token and also implement other server-side functionalities. Paste the following code into the `server.js` file and we'll go through the contents right after:

```js
// src/server.js

  const express = require('express');
  const cors = require('cors');
  const jwt = require('express-jwt');
  const jwks = require('jwks-rsa');
  const firebaseAdmin = require('firebase-admin');
  const path = require('path');

  const app = express();
  app.use(cors());
  app.use('/', express.static(path.join(__dirname, 'public')));

  const jwtCheck = jwt({
    secret: jwks.expressJwtSecret({
      cache: true,
      rateLimit: true,
      jwksRequestsPerMinute: 5,
      jwksUri: `https://${process.env.AUTH0_DOMAIN}/.well-known/jwks.json`
    }),
    audience: process.env.AUTH0_API_AUDIENCE,
    issuer: `https://${process.env.AUTH0_DOMAIN}/`,
    algorithm: 'RS256'
  });

  //...
```

In the code snippet above, you first of all import the previously installed packages, then `Express` is initialized and `cors` is setup as a middleware to respond to cross-origin requests, also the static assets are served. Then there's a bunch of stuff happening right below that, in summary this is what's going on:

The [`express-jwt`](https://github.com/auth0/express-jwt) package is used to initialize a middleware, this middleware is later used to verify JSON web tokens sent over from the client.

In greater detail, when the client makes a request to a certain route on the server, a logged in user's ID token(JWT) signed by Auth0 is sent along in the **Authorization** header, this middleware extracts the token and checks if it is valid. If the token is invalid or has been compromised, it is immediately rejected, otherwise the token is decoded and the payload is sent to the next middleware.

You would have noticed that four configuration properties are used to configure this middleware, let's go through them in detail:

* `secret`: This is the public key used to verify/validate the token. The token sent from the client is expected to be a user ID token signed by Auth0. Auth0 exposes an endpoint for each tenant(you) which points to a JSON file containing a JWK(JSON Web Key) that has been used to sign any token(JWT) issued by Auth0 for that particular tenant, this JWK contains a public key which is used to verify the authenticity of the token. The [`jwks-rsa`](https://www.npmjs.com/package/jwks-rsa) package is then used to retrieve this key from the Auth0 endpoint, it is configured with some properties most importantly the `jwksUri` property which is used to retrieve this key from the Auth0 endpoint.
* `audience`: The audience simply uses your Auth0 `clientID` to identify the recepient of the JWT.
* `issuer`: This is a URI that uniquely identifies the party that issued the JWT, for an Auth0 issued ID Token, this should be the `domain` of your Auth0 application.
* `algorithm`: This signifies the algorithm that was used to sign the JWT. `RS256` is used to sign the token here, it uses an assymetric algorithm meaning that a private key is used to sign the JWT and a public key is used to validate the signature. If you want to know more about this algorithm read this [article](https://auth0.com/blog/navigating-rs256-and-jwks/).

Now create a new folder called `firebase` in the `src` directory, copy the JSON file created previously by your service account into this folder. To ensure that this JSON file isn't commited to your repostory, create a `.gitignore` file in the same `firebase` folder and add the name of the generated JSON file to it, you can rename the file to `firebase-key.json` for readability:

```js
// src/firebase/.gitignore
  firebase-key.json
```

Alright, next you'll setup an Express route which uses the authentication middleware you've setup above to validate the token sent by the client, you'll also use the **Firebase Admin SDK** to create a custom token. Paste the following code into the bottom of the `server.js` file:

```js
// src/server.js
  //...

  const serviceAccount = require('./firebase/firebase-key');

  firebaseAdmin.initializeApp({
    credential: firebaseAdmin.credential.cert(serviceAccount),
    databaseURL: `https://${serviceAccount.project_id}.firebaseio.com`
  });

  app.get('/firebase', jwtCheck, async (req, res) => {
    const {sub: uid} = req.user;

    try {
      const firebaseToken = await firebaseAdmin.auth().createCustomToken(uid);
      res.json({firebaseToken});
    } catch (err) {
      res.status(500).send({
        message: 'Something went wrong acquiring a Firebase token.',
        error: err
      });
    }
  });

  app.listen(3001, () => console.log('Server running on localhost:3001'));
```

The first thing you did above was to initialize the **Firebase Admin SDK**, this is done using some information available in the JSON file generated by your service account.

After that, an Express route `/firebase` is created which the client sends to the user ID token to. Notice `jwtCheck` which represents the authentication middleware is plugged into the `/firebase` route. On every request from the client to this route the middleware extracts the token and validates it, if the token is valid the payload carried by the token is populated onto the `req.user` object and sent to the next middleware, otherwise if the token is invalid it throws an error message at the client and further access is denied.

The payload on the `req.user` object contains a property called `sub` which is used to uniquely identify each user. The Firebase Admin SDK uses this unique identifier to create a custom token and that custom token is then sent back to the client and is used by the client to authenticate with Firebase. That's all for the server-side, next you'll setup your client application.

## Building the Interface
In this section you'll be building the client application which is a simple real-time chat application. The first thing you'll need to do is to setup the UI, so in the `src` directory create a folder called `public`, this will contain all the client side code, after that create a file called `index.html` and put it in the `public` folder. With that done, copy and paste the code below into your `index.html` file:

```html
<!doctype html>
<html lang="en" class="h-100">
<head>
  <!-- Required meta tags -->
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <!-- Bootstrap CSS -->
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css"
        integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO" crossorigin="anonymous">

  <title>Auth0 and Firebase Chat App</title>
</head>
<body class="h-100">

<div class="container-fluid d-flex flex-column h-100">
  <div class="row bg-primary p-2 text-white" style="z-index: 10000; min-height: 60px;">
    <div class="col-12 p-2">
      <div id="profile" class="font-weight-bold"></div>
      <button id="sign-in" type="button" class="btn">Sign In</button>
    </div>
  </div>
  <div class="row flex-fill">
    <div id="chat-area" class="col-12 d-flex flex-column-reverse" style="overflow-y: auto;">
    </div>
  </div>
  <div class="row bg-dark p-2" style="min-height: 55px;">
    <div class="col-12">
      <input type="text" class="form-control" id="message" aria-describedby="message-help"
             placeholder="Enter your message" disabled>
    </div>
  </div>
</div>

<script src="https://www.gstatic.com/firebasejs/5.3.0/firebase-app.js"></script>
<script src="https://www.gstatic.com/firebasejs/5.3.0/firebase-auth.js"></script>
<script src="https://www.gstatic.com/firebasejs/5.3.0/firebase-firestore.js"></script>
<script src="https://cdn.auth0.com/js/auth0/9.7.3/auth0.min.js"></script>
<script src="/app/auth0.js"></script>
<script src="/app/firebase.js"></script>
<script src="/app/index.js"></script>
</body>
</html>
```

Nothing really fancy is going on above, you just setup some styling for the chat application and then some script tags which point to external libraries provided by Auth0 and Firebase. These libraries will enable you initialize and interact with the Auth0 and Firebase application/instances you created previously. Some extra script tags are also added which point to some local files, you'll create these files next.


### Configuring Auth0 on the Client
Now you'll initialize  Auth0 on the client. Create another folder called `app` in the `public` directory and then create a file called `auth0.js` in the `app` folder . This is where you'll initialize and configure Auth0. Paste the code below into this file and we'll explore the contents right after:

```js
// /app/auth0.js
let _auth0Client = null;
let _idToken = null;
let _profile = null;

class Auth0Client {
  constructor() {
    _auth0Client = new auth0.WebAuth({
      domain: 'YOUR_APP_DOMAIN',
      audience: 'https://YOUR_APP_DOMAIN/userinfo',
      clientID: 'YOUR_APP_CLIENTID',
      redirectUri: 'http://localhost:3001/',
      responseType: 'token id_token',
      scope: 'openid profile'
    });
  }

  getIdToken() {
    return _idToken;
  }

  getProfile() {
    return _profile;
  }

  handleCallback() {
    return new Promise((resolve, reject) => {
      _auth0Client.parseHash(async (err, authResult) => {
        window.location.hash = '';
        if (err) return reject(err);

        if (!authResult || !authResult.idToken) {
          // not an authentication request
          return resolve(false);
        }
        _idToken = authResult.idToken;
        _profile = authResult.idTokenPayload;

        return resolve(true);
      });
    });
  }

  signIn() {
    _auth0Client.authorize();
  }
}

const auth0Client = new Auth0Client();
```

First things first, a class `Auth0Client` is created which contains certain methods that'll be used to implement certain functionalities of the application. In the `constructor` function a new instance of your Auth0 application is instantiated using some configuration properties perculiar to your application, replace the `domain`, `clientID` and `audience` property values with the values you previously copied from your Auth0 application settings.

Now let's look at what each method of the `Auth0Client` class does:
When the `signIn` method is called, it triggers a Auth0 lock dialog allowing the user to sign in with their credentials. After the user has been authenticated, they're redirected to the callback URL provided and an ID token is attached to a [hash fragment](https://en.wikipedia.org/wiki/Fragment_identifier) on that callback URL. This ID token contains several information about the user such as email, profile, name, etc...

The `handleCallback` method uses a `parseHash` function provided by Auth0 to extract the ID token from the hash fragment, and stores it in a **private** variable `_idToken`. it also decodes the extracted ID token and stores the payload containing the user profile in another **private** variable called `_profile`. If the `parseHash` function couldn't find any ID token in the hash fragment of the URL, it returns false indicating that there wasn't an authentication request otherwise it returns true, you'll see exactly why this true or false value is useful later on.

The `getIdToken` and `getProfile` functions are pretty self-explanatory, all they do is return the ID token and user profile respectively.

> Note : You'll notice some variables are prefixed with an underscore '_', this is simply a coding style meant to indicate that these variables are meant to be **private** to that function or Class.

### Configuring Firebase on the Client
With that covered, let's set up Firebase on the client, go ahead and create a new file `firebase.js`, this file should also be in the `app` directory. Add the following code into the file:

```js
// /app/firebase.js
let _messagesDb = null;

class Firebase {
  constructor() {
    firebase.initializeApp({
      apiKey: 'YOUR_PROJECT_APIKEY',
      authDomain: 'YOUR_PROJECT_AUTHDOMAIN',
      projectId: 'YOUR_PROJECT_ID',
    });

    // initialize Firestore through Firebase
    _messagesDb = firebase.firestore();

    // disable deprecated features
    _messagesDb.settings({
      timestampsInSnapshots: true
    });
  }

  async addMessage(message) {
    const createdAt = new Date();
    const author = firebase.auth().currentUser.displayName;
    return await _messagesDb.collection('messages').add({
      author,
      createdAt,
      message,
    });
  }

  getCurrentUser() {
    return firebase.auth().currentUser;
  }

  async updateProfile(profile) {
    if (!firebase.auth().currentUser) return;
    await firebase.auth().currentUser.updateProfile({
      displayName: profile.name,
      photoURL: profile.picture,
    });
  }

  async signOut() {
    await firebase.auth().signOut();
  }
 //...
```

In like manner of the previous file, a class `Firebase` is created along with some useful methods. Firebase and Firestore are both initialized in the `constructor` function, make sure you replace the `apiKey`, `authDomain` and `projectId` config values with the equivalent values gotten from your Firebase project. Also, Firestore is initialized through Firebase, the result of that is stored in a variable which you'll use to interact with your Firestore database.

Now let's go through the methods of this `firebaseClient` class and see what exactly they help to achieve:
The `addMessage` method is used to add chat messages into the Firestore database. Anytime a user sends a chat message, this function is called with the message passed in as an argument. Rather than just storing the message in the database, it's also important to know who sent the message and what time it was sent. You can retrieve the user display name from the `firebase.auth` object and use the display name to recognize the author/sender of the message. A timestamp is also created to know when exactly the message was sent, all these information is used to create an object which will be added into the database.

> Firestore is a NOSQL database and data is stored in documents which are stored in collections, collections hold a multitude of documents. You do not need to create a collection explicity, they are created implicitly the first time you add data to a document.

The `_messagesDb` variable which holds a reference to the initialized Firestore database provides some handy methods one of which helps you add a document into a collection, so the constructed object containing the user name, message and date is then added as a document into the `messages` collection on the database.

The `signOut` method logs the user out of Firebase while the `updateProfile` receives the profile information of the currently signed in user and uses that to update the users Firebase profile. The current users profile information is available on the `firebase.auth` object, so if you ever need the user profile, it can be retrieved through the `getCurrentUser` method.


The code below contains the rest of the methods on the `firebaseClient` class, so add that to end of the `firebase.js` file and we'll go through it next:

```js
//...
 setAuthStateListener(listener) {
    firebase.auth().onAuthStateChanged(listener);
  }

  setMessagesListener(listener) {
    _messagesDb.collection('messages').orderBy('createdAt', 'desc').limit(10).onSnapshot(listener);
  }

  async setToken(token) {
    await firebase.auth().signInWithCustomToken(token);
  }

  
}

const firebaseClient = new Firebase();
```

Just as was done previously, let's go through the remaining methods:

You'll want to be notified when a new document get's added to the `messages` collection so you can retrieve some messages and update the UI with it, that's what is done with the `setMessagesListener` method, in this method a real-time listener is attached to the `messages` collection through the `onSnapshot` function, this function takes a callback function as an argument. Whenever a document is added to the `messages` collection, the listener is immediately fired invoking the callback with an array of the last 10 messages present on the `messages` collection sorted by the time the messages were sent.

Similarly, in the `setAuthListener` method, a listener/observer is attached to the `auth` object through the `onAuthStateChanged` function, this function also takes a callback function as an argument and listens for state changes within the Firebase `auth` object such as user login or log out, whenever a state change occurs within this object the callback function is invoked with an argument containing the profile of the logged in user, but if the state change was a log out ,the argument is set to null.

Then the `setToken` method receives the custom token you created previously on the server, and uses this token to authenticate with Firebase.

### Authenticating with Firebase
Next you'll use some of these methods you just created to retrieve a custom token from the server and use it to authenticate with Firebase. For the last time, create a file `index.js`, put this file into the `app` directory. When you're done with that, add the following code to the `index.js` file and we'll go through it next:

```js
// /public/app/index.js
const chatArea = document.getElementById('chat-area');
const messageInput = document.getElementById('message');
const profileElement = document.getElementById('profile');
const signInButton = document.getElementById('sign-in');

messageInput.addEventListener('keyup', async (event) => {
  if (event.code !== 'Enter') return;
  firebaseClient.addMessage(messageInput.value);
  messageInput.value = '';
});

signInButton.addEventListener('click', async () => {
  auth0Client.signIn();
});

async function setFirebaseCustomToken() {
  const response = await fetch('http://localhost:3001/firebase', {
    headers: {
      'Authorization': `Bearer ${auth0Client.getIdToken()}`,
    },
  });

  const data = await response.json();
  await firebaseClient.setToken(data.firebaseToken);
  await firebaseClient.updateProfile(auth0Client.getProfile());
}
//...
```

The first part of the code above is pretty straightforward, an event listener is set on the text input element and listens for input changes, when a user hits the enter key to send a message, the `addMessage` method is called with the message as an argument, an object is then created using this message, date and the user display name, this object is added as a document to the `messages` collection and is stored in the database. Similarly, an event listener is attached to the sign up button, when the user clicks this button, they are automatically redirected by Auth0 to sign in with their credentials.

Also, you might have noticed the `setFirebaseCustomToken` function, when this function is called the client uses the native `Fetch` API to make a request to the `/firebase` route on the server, the ID token of the currently logged in user is sent along to the server through the `Authorization` header using the [Bearer scheme](https://swagger.io/docs/specification/authentication/bearer-authentication/), signifying to the server that a token was sent along, as explained previously the server validates this token and uses the unique `uid` found within the payload to create a custom token. This custom token is then sent back to the client and is used to authenticate with Firebase. When this authentication is successful, you can then update the users Firebase profile with their current profile information.

And finally, you'll make use of some methods created previously in `firebase.js` which listens for user messages and also state changes in the `auth` object, these methods will be used to update the UI accordingly on every message sent and every user log in or log out. Now copy the code below and paste into the `index.js` file:

```js
//...
(async () => {
  firebaseClient.setAuthStateListener((user) => {
    if (!user) {
      profileElement.innerText = '';
      signInButton.style.display = 'inline-block';
      messageInput.disabled = true;
      return;
    }

    profileElement.innerText = `Hello, ${user.displayName}.`;
    signInButton.style.display = 'none';
    messageInput.disabled = false;
    firebaseClient.setMessagesListener((querySnapshot) => {
      chatArea.innerHTML = '';
      querySnapshot.forEach((doc) => {
        const messageContainer = document.createElement('div');
        const timestampElement = document.createElement('small');
        const messageElement = document.createElement('p');

        const messageDate = new Date(doc.data().createdAt.seconds * 1000);
        timestampElement.innerText = doc.data().author + ' - ' + messageDate.toISOString().replace('T', ' ').substring(0, 19);
        messageElement.innerText = doc.data().message;
        messageContainer.appendChild(timestampElement);
        messageContainer.appendChild(messageElement);
        messageContainer.className = 'alert alert-secondary';
        chatArea.appendChild(messageContainer);
      });
    });
  });

  const loggedInThroughCallback = await auth0Client.handleCallback();

  if (loggedInThroughCallback) await setFirebaseCustomToken();
})();
```

In the code above, when the `firebaseClient.setAuthStateListener` method is called, a listener is attached to the `auth` object so that whenever a state change occurs within that object the callback function you defined above can be immediately receiving the logged in users profile as an argument, it's important to check if this argument is null which signifies a user log out. In the case of a user login the user profile can then be used to update certain parts of the UI signifying a logged in user.

Similarly, the `firebaseClient.setMessagesListener` method is used to attach a listener on the `messages` collection so that whenever a write operation occurs on the collection, a query can be made to the database to retrieve the last ten user documents(messages) from the collection, these documents are then passed as an argument to the callback function you defined above and are used to update the UI.

Remember, after the user signs in through Auth0 they get redirected to the allowed callback URL you provided, that URL is supposed to contain a hash fragment containing the ID token of the authenticated user , the `auth0Client.handleCallback` method checks if that ID token is present in the hash fragment of the URL, if the token is present it returns true otherwise it returns false, the value is then stored in the `loggedInThroughCallback` variable.

On the last line you do a simple check to see if this `loggedInThroughCallback` variable has a value of true or false, a value of true implies that the user just got authenticated by Auth0 and can now be authenticated by Firebase so the `setFirebaseCustomToken` method is called which sends this ID token to the server and subsequently receives a custom token which is used to sign the user into Firebase.

## Running the Application
So that's all, let's go and test this out

Open up your terminal in your project directory and set your project environmental variables. Replace the values below with your Auth0 application's `domain` value. The `AUTH0_API_AUDIENCE` value should be replaced with your Auth0 applications `ClientID` . On a windows based system, you can set environmental variables using `set` in place of `export`.

```js
export AUTH0_DOMAIN=YOUR_APP_DOMAIN
export AUTH0_API_AUDIENCE=YOUR_APP_AUDIENCE
```

When that's done, fire up your server by running the following command in your terminal:

```js
node src/server.js
```

Now you can open `localhost:3001` to see the chat application, sign in and try it out.

## Conclusion
In this article you learnt how to use Auth0 as a custom auth system to authenticate with Firebase services and in the process built a simple chat application which helped cement your knowledge of integrating both services into an application.